#!/usr/bin/python3

# IEEExplore early access follower.
# Copyright (C) 2024-2025  bufbrane (bufbrane@bufbrane.com)

# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.

import os
import sys
import time
import argparse
import sqlite3
from selenium import webdriver                  # 需要安装第三方库selenium
from selenium.webdriver.common.by import By
from selenium.webdriver.chrome.service import Service as ChromeService

r"""

# ieaf: IEEEXplore early access follower

一个自动化脚本，用于追踪[IEEEXplore](https://ieeexplore.ieee.org)上的期刊的early access条目。

本脚本服务于如下的工作流：

0. IEEEXplore网站通常会在每天夜里（0:00~8:00 UTF+8，下同）挂出已录用论文的early access；
1. 每天早上运行本脚本抓取early access条目，使用命令行参数`-l`列出未读的论文标题和对应的URL，然后基于论文标题进行初步筛选；
2. 对于感兴趣的论文标题，点击URL跳转到浏览器阅读摘要，进行进一步的筛选；阅读完摘要后如果觉得有必要阅读全文，再用文献管理软件将其下载（推荐以日期创建分类）以备后续阅读；
3. 筛选完毕，使用命令行参数`-nr`将上述论文标记为已读；标记为已读的论文在下次抓取时不再作为未读论文被列出，如此便实现了对每天上新的early access的追踪。


## 前置条件：

0. 本脚本强依赖GUI；Linux非GUI用户可以使用`Xvfb`（只需在命令前添加`xvfb-run`即可）；
1. 安装第三方python库`selenium`；
2. 下载并解压同一版本的测试版chrome和chromedriver：https://googlechromelabs.github.io/chrome-for-testing/
3. 通过`--chrome-path`命令行参数传入chrome可执行文件所在的目录（注意是目录），或是将该目录添加到`PATH`环境变量；
4. 通过`--chromedriver`命令行参数传入chromedriver可执行文件（注意是可执行文件）的路径，或是将该路径设置为`CHROMEDRIVER`环境变量；
5. 通过`--database`命令行参数传入sqlite3数据库文件（注意是文件）的路径，或是将路径设置为`IEAF_DATABASE`环境变量；如未指定数据库文件，则默认使用`$PWD/ieaf.db`；


## 工作方式：

ieaf脚本运行时会默认抓取每本期刊的early access页面的所有文章条目，使用数据库跟踪并找出最新的未读条目；命令行参数`-n`可以跳过抓取。

命令行参数`-l`可以列出所有未读的条目；命令行参数`-r`可以将所有未读的条目设置为已读。


## 爬虫原理：

使用selenium库，通过chromedriver控制chrome加载和渲染网页，然后从最终呈现的HTML中提取所需的数据。

之所以使用上述技术路线而非普通的爬虫库，是因为所需的数据是JS动态加载的，而IEEEXplore网站存在较多的反爬虫措施，本脚本的作者也不愿意花太多精力去应对这些反爬虫措施，于是选择大力出奇迹；
缺点是，本脚本只能在GUI环境中运行（创建的chrome进程必须是GUI进程，`--headless`模式抓不到数据），且每抓一个网页要耗费十多秒，以及运行一个完整的浏览器内核需要几百MB内存；
上述约束条件使得本脚本只适合抓取少量期刊（比如`Ieaf.__init_database()`方法中仅预置了20本期刊）；
考虑到IEEEXplore在国内的访问速度并不快，因此本脚本不打算通过并行方式加速爬取过程；不过，（在经费充足的条件下）计算机可以无限堆算力，但是人的时间精力就这么多，数据抓得再多，你看得完么？


## 数据库设计：

- `items.document_id`字段唯一地定义了一篇论文，取自论文页面的URL（例如https://ieeexplore.ieee.org/abstract/document/4357009）；
- `serials.isnumber`字段唯一地定义了一本期刊，取自期刊的early access页面的URL（例如https://ieeexplore.ieee.org/xpl/tocresult.jsp?isnumber=5594698）；
- `serials.user_sorted_order`字段用于存储用户自定义的期刊优先级（数字越小优先级越高），本脚本的作者的自定义规则如下：
    - 中国计算机学会（CCF）推荐A/B/C类国际英文期刊分别对应1~3级；
    - SCI一区和二区（SCI分区使用中科院分区标准，下同）收录的国际期刊（不包括 IEEE Access）、IEEE Transactions期刊、IEEE Journal期刊对应4级；
    - SCI三区收录的国际期刊、IEEE Letters期刊对应5级；
    
    如果上述自定义规则与某高校博士研究生申请博士学位的论文成果分档标准雷同，纯属此地无银三百两。
- `serials.abbreviation`字段用于存储期刊的缩略名，1~3级采用CCF推荐的缩写，其余采用DOI缩写；

如需跟踪其他期刊或是删除上述预置期刊，请直接在数据库的`serials`表上做增删操作（该功能不常用，作者懒得在脚本中实现，也不愿意将与serials相关的操作改为public方法）；
表结构详见`Ieaf.__init_database()`中的数据库初始化SQL脚本。


## Tips:

由于网页加载的时间是动态变化的，如果在抓取过程中网页加载超时导致报错，可以尝试再次运行本脚本；
事实上本脚本的每个命令行参数对应的操作都满足幂等性，这意味着如果脚本运行出现异常时可以再次尝试运行而不破坏运行结果的一致性；
如果多次尝试都无法解决超时问题，先检查网络连接是否正常，然后考虑修改`Ieaf.__fetch_early_access_items()`中的`browser.implicitly_wait(15)`为更大值（单位为秒）；

"""

class Ieaf:

    def __init__(self, chrome_path: str = None, chromedriver: str = None, database: str = None):

        self.chrome_path = chrome_path
        self.chromedriver = chromedriver
        self.database = database

        if self.chrome_path:
            if os.name == "posix":
                os.environ["PATH"] = chrome_path + ":" + os.environ["PATH"]
            elif os.name == "nt":
                os.environ["PATH"] = chrome_path + ";" + os.environ["PATH"]

        if not self.database:
            self.database = "./ieaf.db"

        # 1. make sure that database (with two tables) exists
        sql = """select count(*) from sqlite_master where type = "table" and ( name = "serials" or name = "items" );"""
        table_count = 0
        try:
            conn = sqlite3.connect(self.database)
            cur = conn.cursor()
            cur.execute(sql)
            for row in cur:
                table_count = row[0]
            conn.close()
        except Exception as e:
            print("Ieaf.__init__() error:", e, " SQL:", sql, file=sys.stderr)
            sys.exit(1)

        if table_count == 0:
            self.__init_database()

        # 2. check database (tables) accessibility        
        self.__delete_item_by_document_id(0xffffffff)
        self.__delete_serial_by_isnumber(0xfffffffe)
        
        if not self.__insert_serial(0xfffffffe, "Ieaf.__init__() test data", "Ieaf.__init__() test data", 0xdeadbeef, "1970-01-01 00:00:00"):
            print("Ieaf.__init__() error: could not insert serial into database. Suggest to use another database file.", file=sys.stderr)
            sys.exit(1)
        
        if not self.__insert_item(0xffffffff, "Ieaf.__init__() test data", 0xfffffffe, "Ieaf.__init__() test data"):
            print("Ieaf.__init__() error: could not insert item into database. Suggest to use another database file.", file=sys.stderr)
            sys.exit(1)
        
        self.__delete_item_by_document_id(0xffffffff)
        self.__delete_serial_by_isnumber(0xfffffffe)


    def __init_database(self)-> None:
    
        initscript = """
    
PRAGMA foreign_keys = off;
BEGIN TRANSACTION;

DROP TABLE IF EXISTS items;

CREATE TABLE items (
    document_id          INTEGER  NOT NULL ON CONFLICT FAIL
                                  PRIMARY KEY ON CONFLICT FAIL
                                  UNIQUE ON CONFLICT FAIL,
    title                STRING   NOT NULL ON CONFLICT FAIL,
    isnumber             INTEGER  REFERENCES serials (isnumber) ON DELETE CASCADE
                                                                ON UPDATE CASCADE
                                  NOT NULL,
    indexed_datetime     DATETIME NOT NULL ON CONFLICT FAIL,
    abstract             TEXT,
    latest_read_datetime DATETIME
);

DROP TABLE IF EXISTS serials;

CREATE TABLE serials (
    isnumber               INTEGER  PRIMARY KEY ON CONFLICT FAIL
                                    UNIQUE ON CONFLICT FAIL
                                    NOT NULL ON CONFLICT FAIL,
    title                  STRING   NOT NULL,
    abbreviation           STRING,
    user_sorted_order      INTEGER,
    latest_update_datetime DATETIME
);

INSERT INTO serials (isnumber, title, abbreviation, user_sorted_order) VALUES (4356907, 'IEEE Transactions on Vehicular Technology', 'TVT', 4);
INSERT INTO serials (isnumber, title, abbreviation, user_sorted_order) VALUES (4357935, 'Proceedings of the IEEE', 'Proc. IEEE', 1);
INSERT INTO serials (isnumber, title, abbreviation, user_sorted_order) VALUES (4358928, 'IEEE Transactions on Intelligent Transportation Systems', 'TITS', 2);
INSERT INTO serials (isnumber, title, abbreviation, user_sorted_order) VALUES (4358975, 'IEEE Transactions on Mobile Computing', 'TMC', 1);
INSERT INTO serials (isnumber, title, abbreviation, user_sorted_order) VALUES (4359146, 'IEEE/ACM Transactions on Networking', 'TON', 1);
INSERT INTO serials (isnumber, title, abbreviation, user_sorted_order) VALUES (4656680, 'IEEE Transactions on Wireless Communications', 'TWC', 2);
INSERT INTO serials (isnumber, title, abbreviation, user_sorted_order) VALUES (5451756, 'IEEE Communications Surveys & Tutorials', 'COMST', 4);
INSERT INTO serials (isnumber, title, abbreviation, user_sorted_order) VALUES (5497975, 'IEEE Transactions on Communications', 'TCOM', 2);
INSERT INTO serials (isnumber, title, abbreviation, user_sorted_order) VALUES (5534602, 'IEEE Communications Letters', 'LCOMM', 5);
INSERT INTO serials (isnumber, title, abbreviation, user_sorted_order) VALUES (5594698, 'IEEE Journal on Selected Areas in Communications', 'JSAC', 1);
INSERT INTO serials (isnumber, title, abbreviation, user_sorted_order) VALUES (5699970, 'IEEE Transactions on Network and Service Management', 'TNSM', 3);
INSERT INTO serials (isnumber, title, abbreviation, user_sorted_order) VALUES (6065724, 'IEEE Wireless Communications Letters', 'LWC', 5);
INSERT INTO serials (isnumber, title, abbreviation, user_sorted_order) VALUES (6354260, 'IEEE Vehicular Technology Magazine', 'MVT', 4);
INSERT INTO serials (isnumber, title, abbreviation, user_sorted_order) VALUES (6702522, 'IEEE Internet of Things Journal', 'IOT', 3);
INSERT INTO serials (isnumber, title, abbreviation, user_sorted_order) VALUES (7557027, 'IEEE Transactions on Green Communications and Networking', 'TGCN', 4);
INSERT INTO serials (isnumber, title, abbreviation, user_sorted_order) VALUES (7593423, 'IEEE Communications Magazine', 'MCOM', 4);
INSERT INTO serials (isnumber, title, abbreviation, user_sorted_order) VALUES (7593426, 'IEEE Wireless Communications', 'MWC', 4);
INSERT INTO serials (isnumber, title, abbreviation, user_sorted_order) VALUES (7593428, 'IEEE Network', 'MNET', 4);
INSERT INTO serials (isnumber, title, abbreviation, user_sorted_order) VALUES (7778228, 'IEEE Transactions on Aerospace and Electronic Systems', 'TAES', 4);
INSERT INTO serials (isnumber, title, abbreviation, user_sorted_order) VALUES (9652444, 'China Communications', 'JCC', 5);

COMMIT TRANSACTION;
PRAGMA foreign_keys = on;

    """

        try:
            conn = sqlite3.connect(self.database)
            cur = conn.cursor()
            cur.executescript(initscript)
            conn.close()
        except Exception as e:
            print("Ieaf.__init_database() error:", e, initscript, file=sys.stderr)
            sys.exit(1)


    def __get_item_by_document_id(self, document_id: int)-> dict:

        result = dict()

        sql = """select document_id, title, isnumber, indexed_datetime, abstract, latest_read_datetime from items where document_id = {};""".format(document_id)

        try:
            conn = sqlite3.connect(self.database)
            cur = conn.cursor()
            cur.execute(sql)
            for row in cur:
                result["document_id"]           = row[0]
                result["title"]                 = row[1]
                result["isnumber"]              = row[2]
                result["indexed_datetime"]      = row[3]
                result["abstract"]              = row[4]
                result["latest_read_datetime"]  = row[5]
            conn.close()
        except Exception as e:
            print("Ieaf.__get_item_by_document_id() error:", e, " SQL:", sql, file=sys.stderr)
            sys.exit(1)

        return result


    def __get_all_serials_isnumber(self)-> list:

        result = list()

        sql = """select isnumber, latest_update_datetime from serials order by user_sorted_order asc, isnumber asc;"""
        
        try:
            conn = sqlite3.connect(self.database)
            cur = conn.cursor()
            cur.execute(sql)
            for row in cur:
                result.append(row[0])
            conn.close()
        except Exception as e:
            print("Ieaf.__get_all_serials_isnumber() error:", e, " SQL:", sql, file=sys.stderr)
            sys.exit(1)
            
        return result


    def __get_serial_by_isnumber(self, isnumber: int)-> dict:

        result = dict()

        sql = """select isnumber, title, abbreviation, user_sorted_order, latest_update_datetime from serials where isnumber = {};""".format(isnumber)

        try:
            conn = sqlite3.connect(self.database)
            cur = conn.cursor()
            cur.execute(sql)
            for row in cur:
                result["isnumber"]               = row[0]
                result["title"]                  = row[1]
                result["abbreviation"]           = row[2]
                result["user_sorted_order"]      = row[3]
                result["latest_update_datetime"] = row[4]
            conn.close()
        except Exception as e:
            print("Ieaf.__get_serial_by_isnumber() error:", e, " SQL:", sql, file=sys.stderr)
            sys.exit(1)

        return result


    def __get_unread_items_in_serial(self, isnumber: int)-> dict:

        result = dict()

        sql = """select document_id, title from items where isnumber = {} and latest_read_datetime = "" order by document_id asc;""".format(isnumber)

        try:
            conn = sqlite3.connect(self.database)
            cur = conn.cursor()
            cur.execute(sql)
            for row in cur:
                result[row[0]] = row[1]
            conn.close()
        except Exception as e:
            print("Ieaf.__get_unread_items_in_serial() error:", e, " SQL:", sql, file=sys.stderr)
            sys.exit(1)

        return result


    def __update_item(self, document_id: int, title: str, isnumber: int, indexed_datetime: str, abstract: str = "", latest_read_datetime: str = "")-> None:

        sql = """update items set title = "{}", isnumber = {}, indexed_datetime = "{}", abstract = "{}", latest_read_datetime = "{}" 
            where document_id = {};""".format(title.replace('"', '\''), isnumber, indexed_datetime, abstract.replace('"', '\''), latest_read_datetime, document_id)

        try:
            conn = sqlite3.connect(self.database)
            cur = conn.cursor()
            cur.execute(sql)
            conn.commit()
            conn.close()
        except Exception as e:
            print("Ieaf.__update_item() error:", e, " SQL:", sql, file=sys.stderr)
            sys.exit(1)


    def __insert_serial(self, isnumber: int, title: str, abbreviation: str = "", user_sorted_order: int = 0, latest_update_datetime: str = "")-> bool:

        sql = """insert into serials (isnumber, title, abbreviation, user_sorted_order, latest_update_datetime) VALUES 
            ({}, "{}", "{}", "{}", "{}");""".format(isnumber, title.replace('"', '\''), isnumber, abbreviation, user_sorted_order, latest_update_datetime)
        
        try:
            conn = sqlite3.connect(self.database)
            cur = conn.cursor()
            cur.execute(sql)
            conn.commit()
            conn.close()
        except Exception as e:
            print("Ieaf.__insert_serial() error:", e, " SQL:", sql, file=sys.stderr)
            return False

        return True


    def __insert_item(self, document_id: int, title: str, isnumber: int, abstract: str = "")-> bool:

        indexed_datetime = time.strftime("%Y-%m-%d %H:%M:%S", time.localtime())

        # if item already exists, do update command rather than insert 
        item = self.__get_item_by_document_id(document_id)
        if len(item) != 0:
            self.__update_item(document_id, title, isnumber, indexed_datetime, abstract, item["latest_read_datetime"])
            return

        # if item not exist, do insert command
        sql = """insert into items (document_id, title, isnumber, indexed_datetime, abstract, latest_read_datetime) VALUES 
            ({}, "{}", {}, "{}", "{}", "{}");""".format(document_id, title.replace('"', '\''), isnumber, indexed_datetime, abstract.replace('"', '\''), "")

        try:
            conn = sqlite3.connect(self.database)
            cur = conn.cursor()
            cur.execute("""begin transaction;""")
            cur.execute(sql)
            cur.execute("""update serials set latest_update_datetime = "{}" where isnumber = {};""".format(indexed_datetime, isnumber))
            cur.execute("""end transaction;""")
            conn.commit()
            conn.close()
        except Exception as e:
            print("Ieaf.__insert_item() error:", e, " SQL:", sql, file=sys.stderr)
            return False
        
        return True
    

    def __delete_serial_by_isnumber(self, isnumber: int)-> bool:

        sql = """delete from serials where isnumber = {};""".format(isnumber)
        
        try:
            conn = sqlite3.connect(self.database)
            cur = conn.cursor()
            cur.execute(sql)
            conn.commit()
            conn.close()
        except Exception as e:
            print("Ieaf.__delete_serial_by_isnumber() error:", e, " SQL:", sql, file=sys.stderr)
            return False

        return True


    def __delete_item_by_document_id(self, document_id: int)-> bool:

        sql = """delete from items where document_id = {};""".format(document_id)
        
        try:
            conn = sqlite3.connect(self.database)
            cur = conn.cursor()
            cur.execute(sql)
            conn.commit()
            conn.close()
        except Exception as e:
            print("Ieaf.__delete_item_by_document_id() error:", e, " SQL:", sql, file=sys.stderr)
            return False
        
        return True


    def __fetch_early_access_items(self, isnumber: int, sortType: str = "vol-only-newest", rowsPerPage: int = 100, pageNumber: int = 1)-> list:
        
        result = list()

        try:
            service = ChromeService(executable_path=self.chromedriver)
            options = webdriver.ChromeOptions()
            browser = webdriver.Chrome(service=service, options=options)

            url = "https://ieeexplore.ieee.org/xpl/tocresult.jsp?isnumber={}&sortType={}&rowsPerPage={}&pageNumber={}".format(isnumber, sortType, rowsPerPage, pageNumber)
            browser.get(url)
            browser.implicitly_wait(15) # waiting for page loading completed (empirical value)

            # extract items list
            publicationIssueMainContent = browser.find_element(By.ID, "publicationIssueMainContent global-margin-px")
            
            # extract each of items 
            for item in publicationIssueMainContent.find_elements(By.CLASS_NAME, "List-results-items"): 

                temp_dict = dict()

                # extract document_id
                href = item.find_element(By.TAG_NAME, "a").get_attribute("href")
                href = href.lstrip("https://ieeexplore.ieee.org/document/")
                href = href.rstrip("/")
                temp_dict["document_id"] = href

                # extract title
                temp_dict["title"] = item.find_element(By.TAG_NAME, "a").text

                # TODO: extract abstract

                result.append(temp_dict)

            browser.quit()

        except Exception as e:
            print("Ieaf.__fetch_early_access_items() error:", e, file=sys.stderr)
            sys.exit(1)

        return result


    def __check_chrome_and_chromedriver(self)-> None:
        
        if os.name == "posix": # for Linux (/bin/sh)
            if os.system("chrome --version > /dev/null 2>&1") == 0:
                pass
            elif os.system("chromium --version > /dev/null 2>&1") == 0:
                pass
            else:
                print("Error: cound not find chrome/chromium.", file=sys.stderr)
                sys.exit(1)

            if os.system("{} --version > /dev/null 2>&1".format(self.chromedriver)) != 0:
                print("Error: cound not find chromedriver.", file=sys.stderr)
                sys.exit(1)

        elif os.name == "nt": # for Windows (C:\Windows\System32\cmd.exe)
            if os.system("where chrome 1>NUL 2>NUL") == 0:
                pass
            elif os.system("where chromium 1>NUL 2>NUL") == 0:
                pass
            else:
                print("Error: cound not find chrome/chromium.", file=sys.stderr)
                sys.exit(1)

            if os.system("{} --version 1>NUL 2>NUL".format(self.chromedriver)) != 0:
                print("Error: cound not find chromedriver.", file=sys.stderr)
                sys.exit(1)


    def update_early_access(self, isnumber_list: list = list())-> None:
        '''
        if isnumber_list is empty then update all the serials, otherwise only the serials in isnumber_list is updated.
        '''

        self.__check_chrome_and_chromedriver()

        if len(isnumber_list) == 0:
            isnumber_list = self.__get_all_serials_isnumber()

        for isnumber in isnumber_list:
            # to ensure the idempotence of the operation, delete the existing unread items first.
            for item in self.__get_unread_items_in_serial(isnumber):
                self.__delete_item_by_document_id(item)

            # fetch no more than 20 pages (100 items per page) of each serials
            for pageNumber in range(1, 20):
                temp_num_of_unread_items = len(self.__get_unread_items_in_serial(isnumber))
                for item in self.__fetch_early_access_items(isnumber, pageNumber):
                    self.__insert_item(item["document_id"], item["title"], isnumber)
                # newly fetched items less than 100 thus no need to fetch more pages
                if len(self.__get_unread_items_in_serial(isnumber)) - temp_num_of_unread_items < 100:
                    break
            

    def get_unread_statistics(self)-> dict:

        result = dict()

        sql = """select serials.title, count(document_id) from items inner join serials on items.isnumber = serials.isnumber 
                    where items.latest_read_datetime = "" group by items.isnumber order by serials.user_sorted_order asc, items.isnumber asc;"""

        try:
            conn = sqlite3.connect(self.database)
            cur = conn.cursor()
            cur.execute(sql)
            for row in cur:
                result[row[0]] = row[1]
            conn.close()
        except Exception as e:
            print("Ieaf.get_unread_statistics() error:", e, " SQL:", sql, file=sys.stderr)
            sys.exit(1)

        return result


    def get_all_unread_items(self)-> list:

        result = list()

        for isnumber in self.__get_all_serials_isnumber():
            unread_items = self.__get_unread_items_in_serial(isnumber)
            for document_id in unread_items:
                temp_dict = dict()
                temp_dict["title"] = unread_items[document_id]
                temp_dict["serials"] = isnumber
                temp_dict["abstract"] = (self.__get_item_by_document_id(document_id))["abstract"]
                temp_dict["document_id"] = document_id
                temp_dict["abbreviation"] = (self.__get_serial_by_isnumber(isnumber))["abbreviation"]
                result.append(temp_dict)

        return result


    def set_read_flag(self, document_id_list: list = list())-> None:

        latest_read_datetime = time.strftime("%Y-%m-%d %H:%M:%S", time.localtime())
        sql = ""

        if len(document_id_list) == 0: # set latest_read_datetime on all unread documents
            try:
                conn = sqlite3.connect(self.database)
                cur = conn.cursor()
                sql = """update items set latest_read_datetime = "{}" where latest_read_datetime = "";""".format(latest_read_datetime)
                cur.execute(sql)
                conn.commit()
                conn.close()
            except Exception as e:
                print("Ieaf.set_read_flag() error:", e, " SQL:", sql, file=sys.stderr)
                sys.exit(1)
        else:
            try:
                conn = sqlite3.connect(self.database)
                cur = conn.cursor()
                cur.execute("""begin transaction;""")
                for document_id in document_id_list:
                    sql = """update items set latest_read_datetime = "{}" where document_id = {};""".format(latest_read_datetime, document_id)
                    cur.execute(sql)
                cur.execute("""end transaction;""")
                conn.commit()
                conn.close()
            except Exception as e:
                print("Ieaf.set_read_flag() error:", e, " SQL:", sql, file=sys.stderr)
                sys.exit(1)


def parse_args()-> argparse.Namespace:

        parser = argparse.ArgumentParser(prog="ieaf", description="ieaf is an acronym of IEEExplore early access follower.", epilog="https://github.com/bufbrane/ieaf")
        
        parser.add_argument("-n", "--no-update", action="store_true", dest="no_update", help="skip fetching early access items from IEEExplore")
        parser.add_argument("-l", "--list", action="store_true", help="list all of unread documents")
        parser.add_argument("-r", "--read", action="store_true", help="set the read flag on all of unread documents")
        parser.add_argument("--chrome-path", action="store", help="set the Chrome browser directory path")
        parser.add_argument("--chromedriver", action="store", default=os.getenv("CHROMEDRIVER"), help="set the chromedriver executable file path")
        parser.add_argument("--database", action="store", default=os.getenv("IEAF_DATABASE"), help="set the database file path")
        
        return parser.parse_args()


def main():

    args = parse_args()

    ieaf = Ieaf(args.chrome_path, args.chromedriver, args.database)

    if not args.no_update:
        ieaf.update_early_access()
            
    if args.list:
        items = ieaf.get_unread_statistics()
        if len(items) > 0:
            print("Unread document statistics: ")
            for key in items: 
                print("· {}: {}".format(key, items[key]))
            print("\n")

        items = ieaf.get_all_unread_items()
        for i in range(len(items)):
            item = items[i]
            if item["abbreviation"] != "":
                item["serials"] = item["abbreviation"]
            print("({})".format(i + 1), (str(item["title"])).replace("\n", ""), "|", item["serials"])
            print("https://ieeexplore.ieee.org/document/{}  \n".format(item["document_id"]))

    if args.read:
        if input("Do you want to set the read flag on unread documents? [y/N] ") == "y":
            ieaf.set_read_flag()
        else:
            print("abort.")
            sys.exit(1)


if __name__ == "__main__":
    main()
